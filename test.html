<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8" />
    <title>MediaPipe EAR計算</title>
    <style>
        video,
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #blinkCountDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            font-weight: bold;
            color: yellow;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <video id="video" width="640" height="480" autoplay muted playsinline></video>
    <canvas id="canvas" width="640" height="480"></canvas>
    <div id="blinkCountDisplay">瞬き: 0 回</div>

    <!-- MediaPipe ライブラリ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const blinkDisplay = document.getElementById('blinkCountDisplay');

        const RIGHT_EYE_EAR_INDICES = {
            left: 33,
            right: 133,
            top1: 159,
            top2: 160,
            bottom1: 145,
            bottom2: 144
        };

        const EAR_THRESHOLD = 0.17;
        let blinkCount = 0;
        let lastBlink = false;

        const faceMesh = new FaceMesh({
            locateFile: (file) =>
                `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });
        camera.start();

        function getDistance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiFaceLandmarks) {
                for (const landmarks of results.multiFaceLandmarks) {
                    const l = landmarks[RIGHT_EYE_EAR_INDICES.left];
                    const r = landmarks[RIGHT_EYE_EAR_INDICES.right];
                    const t1 = landmarks[RIGHT_EYE_EAR_INDICES.top1];
                    const t2 = landmarks[RIGHT_EYE_EAR_INDICES.top2];
                    const b1 = landmarks[RIGHT_EYE_EAR_INDICES.bottom1];
                    const b2 = landmarks[RIGHT_EYE_EAR_INDICES.bottom2];

                    const vertical1 = getDistance(t1, b1);
                    const vertical2 = getDistance(t2, b2);
                    const horizontal = getDistance(l, r);
                    const ear = (vertical1 + vertical2) / (2.0 * horizontal);

                    // 瞬き判定
                    const isBlink = ear < EAR_THRESHOLD;
                    if (isBlink && !lastBlink) {
                        blinkCount++;
                        blinkDisplay.textContent = `瞬き: ${blinkCount} 回`;
                        console.log(`瞬き検出: ${blinkCount} 回`);
                    }
                    lastBlink = isBlink;

                    // ランドマーク描画
                    for (let i = 0; i < landmarks.length; i++) {
                        const x = landmarks[i].x * canvasElement.width;
                        const y = landmarks[i].y * canvasElement.height;

                        canvasCtx.beginPath();
                        canvasCtx.arc(x, y, 1.5, 0, 2 * Math.PI);
                        canvasCtx.fillStyle = "red";
                        canvasCtx.fill();
                    }
                }
            }

            canvasCtx.restore();
        }
    </script>
</body>

</html>